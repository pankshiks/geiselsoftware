--- lib/backup_migrate_core/src/Plugin/README.md
+++ src/Core/Plugin/README.md
@@ -66,7 +66,7 @@ If a plugin wishes to be called for a given operation it simply needs to define
 #### Operation Weights ####
 The order in which plugins are called cannot be guaranteed. However, if a plugin needs to run in a specific order it may specify a weight for each operation it implements. To specify a weight it must implement a `opWeight()` method which takes an operation name and returns a numerical weight. Plugins are called from lowest to highest and plugins which do not specify a weight are considered to have a weight of `0`.
 
-To specify the weight of may operations it may be easier to extend the `\BackupMigrate\Core\Plugin\PluginBase` class and override the `supportedOps()` method which returns an array of supported operations and their weight:
+To specify the weight of may operations it may be easier to extend the `\Drupal\backup_migrate\Core\Plugin\PluginBase` class and override the `supportedOps()` method which returns an array of supported operations and their weight:
 
 	public function supportedOps() {
 	    return [
@@ -78,7 +78,7 @@ To specify the weight of may operations it may be easier to extend the `\BackupM
 ### Calling Other Plugins ###
 Plugins can call other plugins using the Plugin Manager. For example, a source plugin might want to expose a line-item filter operation to allow other plugins to alter single values before they are added to the backup file. An encryption plugin may want to delegate the actual work of encrypting to other sub-plugins for better code organization and extendability.
 
-By default plugins are not given access to the plugin manager. However, if a plugin implements the `\BackupMigrate\Core\Plugin\PluginCallerInterface` then the plugin manager will inject itself into the plugin for use when the plugin is prepared for use. The `\BackupMigrate\Core\Plugin\PluginCallerTrait` can be used to implement the actual requirements of the interface. Plugins with this interface and trait will be able to use `$this->plugins()` to access the plugin manager:
+By default plugins are not given access to the plugin manager. However, if a plugin implements the `\Drupal\backup_migrate\Core\Plugin\PluginCallerInterface` then the plugin manager will inject itself into the plugin for use when the plugin is prepared for use. The `\Drupal\backup_migrate\Core\Plugin\PluginCallerTrait` can be used to implement the actual requirements of the interface. Plugins with this interface and trait will be able to use `$this->plugins()` to access the plugin manager:
 
 	class MyPlugin implements PluginCallerInterface {
 		use PluginCallerTrait;
@@ -104,7 +104,7 @@ Any service provided by the service locator will be injected into a plugin when
 See: [Services](https://github.com/backupmigrate/backup_migrate_core/tree/master/src/Service)
 	
 ### Creating New Temporary Files ###
-If a plugin needs to create a new temporary file (for example to decompress a backup file). It may request that the TempFileManager be injected by implementing `\BackupMigrate\Core\Plugin\FileProcessorInterface` and using the `\BackupMigrate\Core\Plugin\FileProcessorTrait`. This will allow the following:
+If a plugin needs to create a new temporary file (for example to decompress a backup file). It may request that the TempFileManager be injected by implementing `\Drupal\backup_migrate\Core\Plugin\FileProcessorInterface` and using the `\Drupal\backup_migrate\Core\Plugin\FileProcessorTrait`. This will allow the following:
 
 	class MyFilePlugin implements FileProcessorInterface {
 		use FileProcessorTrait;
